/*
 * Copyright 2019 GHM Mobile Development GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.free2move.geoscala

import com.github.plokhotnyuk.jsoniter_scala.core._
import com.github.plokhotnyuk.jsoniter_scala.macros._
import scala.collection.mutable.ListBuffer

object jsoniter_scala {
  // Uncomment for printing of codecs generated by macros
  // implicit val printCodec: CodecMakerConfig.PrintCodec = new CodecMakerConfig.PrintCodec {}

  implicit val coordinateCodec: JsonValueCodec[Coordinate] =
    new JsonValueCodec[Coordinate] {
      override def decodeValue(in: JsonReader, default: Coordinate): Coordinate =
        if (in.isNextToken('[')) {
          val lon = in.readDouble()
          if (!in.isNextToken(',')) in.commaError()
          val lat = in.readDouble()
          while (in.isNextToken(',')) in.skip()
          if (!in.isCurrentToken(']')) in.arrayEndOrCommaError()
          new Coordinate(lon, lat)
        } else in.readNullOrTokenError(default, '[')

      override def encodeValue(x: Coordinate, out: JsonWriter): Unit = {
        out.writeArrayStart()
        out.writeVal(x.longitude)
        out.writeVal(x.latitude)
        out.writeArrayEnd()
      }

      override def nullValue: Coordinate = null
    }

  implicit val listOfCoordinatesCodec: JsonValueCodec[List[Coordinate]] = JsonCodecMaker.make

  implicit val listOfListOfCoordinatesCodec: JsonValueCodec[List[List[Coordinate]]] = JsonCodecMaker.make

  implicit val listOfListOfListOfCoordinatesCodec: JsonValueCodec[List[List[List[Coordinate]]]] = JsonCodecMaker.make

  implicit val pointCodec: JsonValueCodec[Point] =
    makeGeometryCodec("Point", _.coordinates, Point.apply)

  implicit val multiPointCodec: JsonValueCodec[MultiPoint] =
    makeGeometryCodec("MultiPoint", _.coordinates, MultiPoint.apply)

  implicit val lineStringCodec: JsonValueCodec[LineString] =
    makeGeometryCodec("LineString", _.coordinates, LineString.apply)

  implicit val multiLineStringCodec: JsonValueCodec[MultiLineString] =
    makeGeometryCodec("MultiLineString", _.coordinates, MultiLineString.apply)

  implicit val polygonCodec: JsonValueCodec[Polygon] =
    makeGeometryCodec("Polygon", _.coordinates, Polygon.apply)

  implicit val multiPolygonCodec: JsonValueCodec[MultiPolygon] =
    makeGeometryCodec("MultiPolygon", _.coordinates, MultiPolygon.apply)

  private[this] def makeGeometryCodec[C, G <: Geometry](tpe: String, coords: G => C, geom: C => G)(implicit
      coordinatesCodec: JsonValueCodec[C]
  ): JsonValueCodec[G] =
    new JsonValueCodec[G] {
      override val nullValue: G = null.asInstanceOf[G]

      override def decodeValue(in: JsonReader, default: G): G =
        if (in.isNextToken('{')) {
          var coordinates: C = coordinatesCodec.nullValue
          var mask = 3
          var len = -1
          while (len < 0 || in.isNextToken(',')) {
            len = in.readKeyAsCharBuf()
            if (in.isCharBufEqualsTo(len, "type")) {
              if ((mask & 0x1) != 0) mask ^= 0x1
              else in.duplicatedKeyError(len)
              if (!in.isCharBufEqualsTo(in.readStringAsCharBuf(), tpe)) {
                in.discriminatorValueError("type")
              }
            } else if (in.isCharBufEqualsTo(len, "coordinates")) {
              if ((mask & 0x2) != 0) mask ^= 0x2
              else in.duplicatedKeyError(len)
              coordinates = coordinatesCodec.decodeValue(in, coordinates)
            } else in.skip()
          }
          if (!in.isCurrentToken('}')) in.objectEndOrCommaError()
          if (mask != 0) error(in, mask)
          geom(coordinates)
        } else in.readNullOrTokenError(default, '}')

      override def encodeValue(x: G, out: JsonWriter): Unit = {
        out.writeObjectStart()
        out.writeNonEscapedAsciiKey("type")
        out.writeNonEscapedAsciiVal(tpe)
        out.writeNonEscapedAsciiKey("coordinates")
        coordinatesCodec.encodeValue(coords(x), out)
        out.writeObjectEnd()
      }

      private[this] def error(in: JsonReader, mask: Int): Nothing =
        in.requiredFieldError {
          if ((mask & 0x1) != 0) "type"
          else "coordinates"
        }
    }

  implicit val geometryCodec: JsonValueCodec[Geometry] = JsonCodecMaker.make

  implicit def featureCodec[P](implicit propertiesCodec: JsonValueCodec[P]): JsonValueCodec[Feature[P]] =
    new JsonValueCodec[Feature[P]] {
      override val nullValue: Feature[P] = null.asInstanceOf[Feature[P]]

      override def decodeValue(in: JsonReader, default: Feature[P]): Feature[P] =
        if (in.isNextToken('{')) {
          var properties: P = propertiesCodec.nullValue
          var geometry: Geometry = geometryCodec.nullValue
          var mask = 7
          var len = -1
          while (len < 0 || in.isNextToken(',')) {
            len = in.readKeyAsCharBuf()
            if (in.isCharBufEqualsTo(len, "type")) {
              if ((mask & 0x1) != 0) mask ^= 0x1
              else in.duplicatedKeyError(len)
              if (!in.isCharBufEqualsTo(in.readStringAsCharBuf(), "Feature")) {
                in.discriminatorValueError("type")
              }
            } else if (in.isCharBufEqualsTo(len, "properties")) {
              if ((mask & 0x2) != 0) mask ^= 0x2
              else in.duplicatedKeyError(len)
              properties = propertiesCodec.decodeValue(in, properties)
            } else if (in.isCharBufEqualsTo(len, "geometry")) {
              if ((mask & 0x4) != 0) mask ^= 0x4
              else in.duplicatedKeyError(len)
              geometry = geometryCodec.decodeValue(in, geometry)
            } else in.skip()
          }
          if (!in.isCurrentToken('}')) in.objectEndOrCommaError()
          if (mask != 0) error(in, mask)
          new Feature(properties, geometry)
        } else in.readNullOrTokenError(default, '}')

      override def encodeValue(x: Feature[P], out: JsonWriter): Unit = {
        out.writeObjectStart()
        out.writeNonEscapedAsciiKey("type")
        out.writeNonEscapedAsciiVal("Feature")
        out.writeNonEscapedAsciiKey("properties")
        propertiesCodec.encodeValue(x.properties, out)
        out.writeNonEscapedAsciiKey("geometry")
        geometryCodec.encodeValue(x.geometry, out)
        out.writeObjectEnd()
      }

      private[this] def error(in: JsonReader, mask: Int): Nothing =
        in.requiredFieldError {
          if ((mask & 0x1) != 0) "type"
          else if ((mask & 0x2) != 0) "properties"
          else "geometry"
        }
    }

  implicit def featureCollectionCodec[P](implicit featureCodec: JsonValueCodec[Feature[P]]): JsonValueCodec[FeatureCollection[P]] =
    new JsonValueCodec[FeatureCollection[P]] {
      override val nullValue: FeatureCollection[P] = null.asInstanceOf[FeatureCollection[P]]

      override def decodeValue(in: JsonReader, default: FeatureCollection[P]): FeatureCollection[P] =
        if (in.isNextToken('{')) {
          var features: List[Feature[P]] = Nil
          var mask = 3
          var len = -1
          while (len < 0 || in.isNextToken(',')) {
            len = in.readKeyAsCharBuf()
            if (in.isCharBufEqualsTo(len, "type")) {
              if ((mask & 0x1) != 0) mask ^= 0x1
              else in.duplicatedKeyError(len)
              if (!in.isCharBufEqualsTo(in.readStringAsCharBuf(), "FeatureCollection")) {
                in.discriminatorValueError("type")
              }
            } else if (in.isCharBufEqualsTo(len, "features")) {
              if ((mask & 0x2) != 0) mask ^= 0x2
              else in.duplicatedKeyError(len)
              if (in.isNextToken('[')) {
                if (!in.isNextToken(']')) {
                  in.rollbackToken()
                  val buf = new ListBuffer[Feature[P]]
                  while ({
                    buf.addOne(featureCodec.decodeValue(in, featureCodec.nullValue))
                    in.isNextToken(',')
                  }) ()
                  if (in.isCurrentToken(']')) features = buf.toList
                  else in.arrayEndOrCommaError()
                } else in.readNullOrTokenError(features, '[')
              }
            } else in.skip()
          }
          if (!in.isCurrentToken('}')) in.objectEndOrCommaError()
          if (mask != 0) error(in, mask)
          new FeatureCollection(features)
        } else in.readNullOrTokenError(default, '}')

      override def encodeValue(x: FeatureCollection[P], out: JsonWriter): Unit = {
        out.writeObjectStart()
        out.writeNonEscapedAsciiKey("type")
        out.writeNonEscapedAsciiVal("FeatureCollection")
        out.writeNonEscapedAsciiKey("features")
        out.writeArrayStart()
        var remainingFeatures = x.features
        while (remainingFeatures ne Nil) {
          featureCodec.encodeValue(remainingFeatures.head, out)
          remainingFeatures = remainingFeatures.tail
        }
        out.writeArrayEnd()
        out.writeObjectEnd()
      }

      private[this] def error(in: JsonReader, mask: Int): Nothing =
        in.requiredFieldError {
          if ((mask & 0x1) != 0) "type"
          else "features"
        }
    }

  implicit def geoJson[P: JsonValueCodec]: JsonValueCodec[GeoJson[P]] =
    new JsonValueCodec[GeoJson[P]] {
      private[this] val fc: JsonValueCodec[Feature[P]] = featureCodec
      private[this] val fcc: JsonValueCodec[FeatureCollection[P]] = featureCollectionCodec
      override val nullValue: GeoJson[P] = null.asInstanceOf[GeoJson[P]]

      override def decodeValue(in: JsonReader, default: GeoJson[P]): GeoJson[P] = {
        in.setMark()
        if (in.isNextToken('{')) {
          if (!in.skipToKey("type")) in.discriminatorError()
          val len = in.readStringAsCharBuf()
          in.rollbackToMark()
          if (in.isCharBufEqualsTo(len, "Feature")) fc.decodeValue(in, fc.nullValue)
          else if (in.isCharBufEqualsTo(len, "FeatureCollection")) fcc.decodeValue(in, fcc.nullValue)
          else geometryCodec.decodeValue(in, geometryCodec.nullValue).asInstanceOf[GeoJson[P]]
        } else {
          val gj = in.readNullOrTokenError(default, '{')
          in.rollbackToMark()
          in.skip()
          gj
        }
      }

      override def encodeValue(x: GeoJson[P], out: JsonWriter): Unit =
        x match {
          case f: Feature[P]            => fc.encodeValue(f, out)
          case fc: FeatureCollection[P] => fcc.encodeValue(fc, out)
          case _                        => geometryCodec.encodeValue(x.asInstanceOf[Geometry], out)
        }
    }
}
